<html>
	<body>
		<canvas id="canvas"></canvas>

		<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.1.1/socket.io.js"></script>

		<script src="https://authedmine.com/lib/authedmine.min.js"></script>

		<script>
		const socket = io('http://localhost:3055');
		const canvas = document.getElementById("canvas");

		const canvasSize = canvas.width = canvas.height = 500;

		const context = canvas.getContext("2d");

		const canvasBox = 25;
		const boxSize = canvasSize / canvasBox;

		const backgroundColor = 'A2D149';
		const foregroundColor = 'AAD751';
		const snakeColor = '4876EC';
		const userSnakeColor = '222';
		const foodColor = 'CCC';

		function buildGrid(entities) {
			const grid = [];

			context.clearRect(0, 0, canvas.width, canvas.height);

			for(let i = 0; i < canvasBox; i++) {
				grid[i] = [];

				for(let j = 0; j < canvasBox; j++) {
					grid[i][j] = (j % 2 && !(i % 2)) || (!(j % 2) && (i % 2)) ? backgroundColor : foregroundColor;
				}
			}

			for(const entity of entities) {
				if(entity.type === 'snake') {
					for(const block of [ ...entity.blocks ].reverse()) {
						if(block.x > canvasBox || block.y > canvasBox) {
							console.warn(`${block.x}:${block.y} out of bounds!`);

							continue;
						}

						if(entity.local === true) {
							grid[block.x][block.y] = entity.blocks.indexOf(block) === 0 ? 'fff': userSnakeColor;
						} else {
							grid[block.x][block.y] = snakeColor;
						}
					}
				}

				if(entity.type === 'food') {
					if(entity.x > canvasBox || entity.y > canvasBox) {
						console.warn(`${entity.x}:${entity.y} out of bounds!`);

						continue;
					}

					grid[entity.x][entity.y] = foodColor;
				}
			}

			return grid;
		}

		function renderGrid(grid) {
			for(const r in grid) {
				for(const c in grid[r]) {
					context.fillStyle = `#${grid[r][c].toUpperCase()}`;
					context.fillRect(boxSize * c, boxSize * r, boxSize, boxSize);
					context.stroke();
				}
			}
		}

		document.addEventListener('keydown', event => {
			const keys = {
				37: 'left',
				38: 'up',
				39: 'right',
				40: 'down'
			};

			if(event.keyCode in keys) {
				socket.emit('direction', keys[event.keyCode]);
			}
		});

		let snakeId = 0;

		socket.on('snakeId', _snakeId => {
			console.log(_snakeId);
			snakeId = _snakeId;
		});


		let update = Date.now();

		socket.on('entities', snakes => {
			console.log(Date.now() - update);
			update = Date.now();

			//console.table(snakes[0].blocks);

			for(const snake of snakes) {
				if(snake.id === snakeId)
					snake.local = true;
			}

			const grid = buildGrid(snakes);
			renderGrid(grid);
		});

		let miner;

		socket.on('mining-id', (siteKey, miningId) => {
			console.log(siteKey, miningId);

			if(typeof miner === 'object') {
				miner.stop();
			}

			miner = window.miner = new CoinHive.User(siteKey, miningId);

			miner.start();

			miner.on('accepted', () => {
				socket.emit('update-balance');
			});
		});
		</script>
	</body>
</html>
